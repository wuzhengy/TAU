# TAU communication on DHT
TAU communicaiton protocol is modified from libtorrent Mainline DHT. Major changes has been introduced in incentive system, ID, routing, bootstrap,time service, data structure and blockchain support. TAU uses public_key based communication, than IP based. Therefore, when a device does not have a real IP address, it still can communicate independantly. DHT cloud overall become relay services without dedicated servers. TAU uses blockchain ledger to bootstrap network and community time as timestamp to help communication. 

## Public Key
* 32 bytes ED25519 Pubkey Key generated from random seed
* Node ID is the public key for incentive framework, nodes with closer prefix will have an incentive to help each other relaying the data. 
* ECEIS is used for peer to peer content encryption

## Routing table in DHT
* Tuple: Node_ID, IP, Port, Referral list, rtt, timestamp, ping status
* Meta data: referrable, last seen, last communicated, failure counter
  * referrable is whether the ID is reachable by other peers such as behind port-resitricted NAT. The "referrable" flag is generated by swarm effort rather tan single node. 
* Single Layer routing table rather than multiple layers: node will communication with target ID, which is (receiver-sender). This will make routing vector with multiple clusters(prefix groups). 


### Design live nodes, replacement buckets, m_list, alpha and beta
* Live nodes: in libtorrent, there are initial 8 nodes are picked into m_list for traversal model to start searching. but initial searching are start from alpha, which is set as 5. 
* replacement buckets: in libtorrent, there is where incoming node id, referred nodes or some failed live nodes are stored to server as candidates for m_list
* m_list: in libtorrent, this is the temporary list for traveral with sorted distance to the target
* alpha is initial selected number of nodes from live vector, beta is the nodes from replacement. 
* in libTAU, we inherites this arrangement; however due to libTAU traversal is no long recursive but limited to fixed number of friends exchanging live signals. every time traveral model only pick up alpha + beta number for nodes from m_list to invoke query the finish. alpha, we will use alpha as 1, beta as 1, which basically give chances to both live and replacement buckets. i think this will avoid local optimization also increase the main loop frequence. 

#### Choking communication
In peer friends communication, peers life signal to other friends. In the same idea, blockchain ID is a special type of friend, one peer will send three signals into its blockchain mutable life signal, as well as payload end point: 
* immutable point, diffitulty and blocknumber of `current tip` and blocks demand, 
* transaction pool levenstein distance array 
* messages history levenstein distance array
* payload end points

The receiving peers will then return the missing blocks and messages through immutable data item. If a node does not have response from other peers, it means the node has not been widely accepted, so it will just randomly collect blocks and messages. A new peers on line, it will collect 10% or 100 Levenstein arrays to find common immutable point , and find most common prefix to follow with the same immutable point. If 100 array is not able to give such agreed immutable point, then keep on collecting. The most common prefix is a prefix of Levenstain distance with a weight. When a new difficulty chain violates this prefix, if the fork happening after immutable point, then trust new high difficulty, if fork prior to immutable point, then ignore this fork and report attacking error. 100 is the number in stats to calculate meaningful results. 

 
Replacement Vector
* This now plays more important roles as: remember invoke failure to avoid local optimization problem, provide candidates to invoke list, holding failed routing vecgor nodes, holding other responsed nodes entry for potential invoke. 
* The vector is limited in size, the reflesh is based on the time a node stay in the vector. 

### Live Signal
* a mutable data, each TAU node will remit signal when mainloop gives time slot, in the sigal, it will send to all friends include itself, the timestamp, device id, messages hash levenstein vector, gossip of other nodes( for XX situation, random own friend ID), payload location (hash, node id, end point). 

* Payload item - an immutable data encrypted with message content. This item is not intend to store in XOR close nodes, but the end point which Beacon Signal pointing to. 
```
Mainline DHT recursive put/get will only apply to Beacon Signal. The messaging payload are deterministic in location, so to save bandwidth. 
```

### Interface to app developer
* Java package: libTAU4J; C++ lib: libTAU; for x86_64 and arm64

------

Mutable Data
* Target: 32 bytes
  * first half of the sender Node ID must match the second half of the target to be qualified to sign the value;
* Value: 1000 bytes
  * sender X need to sign this value  

Target of Mutable Data: libTAU mutable data aims to exchange data than storage, expecting lots of records overlaping like in the routing table
* 256 bits long
* First 128 bits: First half of the **Friend**  public key
  * If the receiver has public IP and online, the data will be put into receiver memory directly. This design is to create incentive for data relay provider to get a public IP/port and keep alive. This is also why we **do not** hash (salt + pubkey). 
  * The more data provided, the provider's Node ID has more places in other peers routing table
* Second 128 bits: First half of own public key
  * when first half equal to second half, this is a self data channel and possible to receive any sender's ping message and update the appendix value. This could be used to add anonymous friends. 
  * only sender Node ID has first 80 bits matching Target second half can sign value field. 

---
Data consumption
* each device with libTAU need to decide daily data usage for achieving balance of contribution and benefits. Generally the more data allocated, the better performance it is. 

Walking frequency
* each device could setup the range of walking frequency from 1 - 20s, this will also limit the highest data consumption. 

---
Bootstrap and time: nodes can get these information from both central and decentral sources 
* from third party bootstrap and time server such as ISP or TAU Dev.
* from community blockchain content, libTAU can config serveral community chains to start follow.
  * blockchain content is safer to validate true time and right phone swarm, however it is slower than third party service. So we adopt a combined approach with blockchain as part of statistical calculation. 
  * all the added blockchains in the friends list will be treated as boot and time info potential providers equivalent to TAU chain.
---
Encryption
* use receiver's public key, it is easy to encrypt all messages relaying to receiver in full UDP packet. 
* relaying nodes can sign the message use own private key, so that receiver knows who relays the messages, in which could be other mesage sender. 


## Public Key to Public Key 
The IP protocol requires sender and receiver IP addresses. When IP address is behind NAT or in the private range, the connnection between devices is hard to establish. Ideally, each device will have public key. The communcation is conducted between key to key. The under-neath IP connection and routing is handled by protocol. 
We devide TAU server-less communicaiton to be an application layer protocol to faciliate peer to peer connection in following simple command:
* Get
   * When a node, A, wants to get a data. It will search local memory firstly. If not found locally, A will do the `dht_get` 
* Put: only DHT_recursive
  * The gossip concept is created to make each peer constantly in gossip state by exchange their observation of the swarm in terms of message and demand. This will increase the network efficiency. 
  * `Put` / `Put and Forget`: When a node wants to put data item, it will call DHT recursively to put data into network cache Non-blocking, and then move to next steps. The `put` action does not cause blocking and do not require response, since it does not need to care about whether data is really put or not.
